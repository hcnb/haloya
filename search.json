[{"title":"Hello World","url":"/2022/06/22/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"Heroku五合一协议共存项目","url":"/2022/06/23/heroku-xary/","content":"1. 简介：\n仅适用于Github下部署\n\nXray内核，支持vless-ws，vmess-ws，trojan-ws，shadowsocks-ws，socks5-ws搭建过程与客户端配置说明\n\n下载后上传到Github上进行部署。注意项目名称说明不要出现有V2ray、Xray等相关字样。\n\n\n2. 操作步骤：2.1 步骤\n在浏览器复制链接   https://dashboard.heroku.com/new?template= 加上上传至Github的项目地址链接，回车进入Heroku参数设置界面\n\n之前没有登录记录的话，会先提示注册并或登录Heroku界面，大家自己注册或者登录下\n\nHeroku app名称与国家随意，最后设置图如下\n\n\n\n\n输入UUID，建议使用V2rayN等工具生成，点击Deploy app，几秒种后就完成安装。\n\n由于使用了Caddy，未设伪装网页，所以点击heroku本地域名时（app.heroku.com）为空白界面，所有反代（workers与pages）测试为绿色200 ok，反代地址也为空白界面，请大家知晓。\n\n\n2.2 关于heroku封杀特征说明：\n项目部署时被强制中断封杀\n\n项目部署后，测个速度也会被封杀\n\n项目部署后，不跑流量，放着不动也会被封杀\n\n\n已证实，heroku封杀看特性，不看流量大小。之前的项目是明文，现在加密了，测试了几周没问题，所以大家可以试试看。\n3.客户端配置如下3.1 IOS端小火箭就可以通吃，安卓端推荐V2rayNG或搭配Kitsunebi\n协议：(vless&#x2F;vmess&#x2F;trojan)-ws\n\n地址：app.heroku.com（自选IP&#x2F;域名）\n\n端口：443\n\n用户ID&#x2F;密码：自定义UUID\n\n传输协议：ws\n\n伪装host：app.heroku.com（workers或pages反代&#x2F;自定义域）\n\n路径path：&#x2F;自定义UUID-协议开头两小写字母\n\n传输安全：tls\n\nSNI：app.heroku.com（workers或pages反代&#x2F;自定义域）\n\n\n其他设置保持默认即可！\n3.2 shadowsocks-ws与socks5-ws推荐用Kitsunebi，配置简单，不需要plugin插件\n地址：app.heroku.com（自选IP&#x2F;域名）\n\n端口：443\n\nshadowsocks密码：自定义UUID\n\nshadowsocks加密方式：chacha20-ietf-poly1305(默认)\n\nsocks5用户名：空\n\n\n3.3 socks5密码：\n传输协议：ws\n\n伪装host：app.heroku.com（workers或pages反代&#x2F;自定义域）\n\n路径path：&#x2F;自定义UUID-协议开头两小写字母\n\n传输安全：tls\n\nSNI(证书域名)：app.heroku.com（workers或pages反代&#x2F;自定义域）\n\n\n其他设置保持默认即可！\n4. 关于为什么套CF以及满足自选IP&#x2F;域名的条件解答（443端口，且TLS开启）\n","categories":["免费"],"tags":["heroku","白嫖"]},{"title":"Microsoft Learn的Azure 临时RDP远程桌面","url":"/2022/06/22/microsoft-widows/","content":"在之前的文章中，我描述过Microsoft Learn的远程桌面。但是那篇文章的方法只能用2个小时。本文的教程是使用Microsoft Learn的Azure的沙箱，来创建临时RDP远程桌面\n1.准备材料\nMicrosoft账号\n\n远程桌面软件\n\n\n2.部署步骤\n打开这个沙箱\n\n点击“激活沙盒”按钮，如未登录Microsoft 账户的会自动跳转登录页面登录\n\n\n\n\n由于Azure沙盒微软是严格限制访问其外网的服务，因此这篇文章会用到我朋友写的加密破解脚本来创建VPS。在右边的Cloud Shell运行以下命令\n\ncurl -skLO bit.do/azurewinvmplus ; chmod +x azurewinvmplus ; ./azurewinvmplus\n\n\n\n\n3.选择VPS地区\n4.选择系统\n5.选择配置，然后等待创建\n6.等待差不多5-10分钟，然后就可以看到RDP的登录信息了\n7.微软远程桌面软件中，计算机名称填写刚刚提示的IP\n8.输入用户名密码\n9.连接到远程桌面，白嫖成功！本文转载自小御坂的破站文章作者: Misaka No文章链接: https://owo.misaka.rest/az-mslearn-windesktop/\n","categories":["免费"],"tags":["免费"]},{"title":"CloudFlare Pages 反代脚本分享","url":"/2022/06/23/cloudFlare-pages/","content":"1. 简介：今天和大家分享几个CloudFlare Pages 反代脚本，来加速富强。\n2. 反代脚本：2.1 单双日轮换反代代码default &#123;  async fetch(request, env) &#123;    const day1 = &#x27;app0.example.com&#x27;    const day2 = &#x27;app1.example.com&#x27;    let url = new URL(request.url);    if (url.pathname.startsWith(&#x27;/&#x27;)) &#123;      let day = new Date()      if (day.getDay() % 2) &#123;        url.hostname = day1      &#125; else &#123;        url.hostname = day2      &#125;      let new_request = new Request(url, request);      return fetch(new_request);    &#125;    return env.ASSETS.fetch(request);  &#125;,&#125;;\n2.2 五天轮换反代代码default &#123;  async fetch(request, env) &#123;    const day1 = &#x27;app0.example.com&#x27;    const day2 = &#x27;app1.example.com&#x27;    const day3 = &#x27;app2.example.com&#x27;    const day4 = &#x27;app3.example.com&#x27;    const day5 = &#x27;app4.example.com&#x27;    let url = new URL(request.url);    if (url.pathname.startsWith(&#x27;/&#x27;)) &#123;      let day = new Date().getDay() % 5;      if (day === 0) &#123;        url.hostname = day1      &#125; else if (day === 1) &#123;        url.hostname = day2      &#125; else if (day === 2) &#123;        url.hostname = day3      &#125; else if (day === 3) &#123;        url.hostname = day4      &#125; else if (day === 4) &#123;        url.hostname = day5      &#125; else &#123;        url.hostname = day1      &#125;      let new_request = new Request(url, request);      return fetch(new_request);    &#125;    return env.ASSETS.fetch(request);  &#125;,&#125;;\n2.3 一周轮换反代代码default &#123;  async fetch(request, env) &#123;    const day1 = &#x27;app0.example.com&#x27;    const day2 = &#x27;app1.example.com&#x27;    const day3 = &#x27;app2.example.com&#x27;    const day4 = &#x27;app3.example.com&#x27;    const day5 = &#x27;app4.example.com&#x27;    const day6 = &#x27;app5.example.com&#x27;    const day7 = &#x27;app6.example.com&#x27;    let url = new URL(request.url);    if (url.pathname.startsWith(&#x27;/&#x27;)) &#123;      let day = new Date().getDay();      if (day === 0) &#123;        url.hostname = day1      &#125; else if (day === 1) &#123;        url.hostname = day2      &#125; else if (day === 2) &#123;        url.hostname = day3      &#125; else if (day === 3) &#123;        url.hostname = day4      &#125; else if (day === 4) &#123;        url.hostname = day5      &#125; else if (day === 5) &#123;        url.hostname = day6      &#125; else if (day === 6) &#123;        url.hostname = day7      &#125; else &#123;        url.hostname = day1      &#125;      let new_request = new Request(url, request);      return fetch(new_request);    &#125;    return env.ASSETS.fetch(request);  &#125;,&#125;;\n\n2.4 任意天数反代代码default &#123;async fetch(request, env) &#123;const cars = [&quot;app1.example.com&quot;,&quot;app2.example.com&quot;,&quot;app3.example.com&quot;,&quot;app4.example.com&quot;,&quot;app5.example.com&quot;];let host = cars[Math.floor(Math.random() * cars.length)]; //随机选择VPS//let host = cars[new Date().getDate() % cars.length]; //每天自动更换VPSlet url = new URL(request.url);if (url.pathname.startsWith(&#x27;/&#x27;)) &#123;url.hostname = host;let new_request = new Request(url,request);return fetch(new_request);&#125;return env.ASSETS.fetch(request);&#125;&#125;;","categories":["免费"],"tags":["cf"]}]